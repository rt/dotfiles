::: {.NAVHEADER}
Bash Guide for Beginners
:::

[Prev](chap_07.md)

Chapter 7. Conditional statements

[Next](sect_07_02.md)

------------------------------------------------------------------------

::: {.sect1}
[]{#sect_07_01}7.1. Introduction to if {#introduction-to-if .sect1}
======================================

::: {.sect2}
[]{#sect_07_01_01}7.1.1. General {#general .sect2}
--------------------------------

At times you need to specify different courses of action to be taken in
a shell script, depending on the success or failure of a command. The
**if** construction allows you to specify such conditions.

The most compact syntax of the **if** command is:

**if TEST-COMMANDS; then CONSEQUENT-COMMANDS; fi**

The **TEST-COMMAND** list is executed, and if its return status is zero,
the **CONSEQUENT-COMMANDS** list is executed. The return status is the
exit status of the last command executed, or zero if no condition tested
true.

The **TEST-COMMAND** often involves numerical or string comparison
tests, but it can also be any command that returns a status of zero when
it succeeds and some other status when it fails. Unary expressions are
often used to examine the status of a file. If the `FILE`{.filename}
argument to one of the primaries is of the form `/dev/fd/N`{.filename},
then file descriptor [\"N\"]{.QUOTE} is checked. `stdin`{.filename},
`stdout`{.filename} and `stderr`{.filename} and their respective file
descriptors may also be used for tests.

::: {.sect3}
### []{#sect_07_01_01_01}7.1.1.1. Expressions used with if {#expressions-used-with-if .sect3}

The table below contains an overview of the so-called
[\"primaries\"]{.QUOTE} that make up the **TEST-COMMAND** command or
list of commands. These primaries are put between square brackets to
indicate the test of a conditional expression.

::: {.table}
[]{#tab_07_01}

**Table 7-1. Primary expressions**

  Primary                                                      Meaning
  ------------------------------------------------------------ ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  \[ `-a`{.option} `FILE`{.filename} \]                        True if `FILE`{.filename} exists.
  \[ `-b`{.option} `FILE`{.filename} \]                        True if `FILE`{.filename} exists and is a block-special file.
  \[ `-c`{.option} `FILE`{.filename} \]                        True if `FILE`{.filename} exists and is a character-special file.
  \[ `-d`{.option} `FILE`{.filename} \]                        True if `FILE`{.filename} exists and is a directory.
  \[ `-e`{.option} `FILE`{.filename} \]                        True if `FILE`{.filename} exists.
  \[ `-f`{.option} `FILE`{.filename} \]                        True if `FILE`{.filename} exists and is a regular file.
  \[ `-g`{.option} `FILE`{.filename} \]                        True if `FILE`{.filename} exists and its SGID bit is set.
  \[ `-h`{.option} `FILE`{.filename} \]                        True if `FILE`{.filename} exists and is a symbolic link.
  \[ `-k`{.option} `FILE`{.filename} \]                        True if `FILE`{.filename} exists and its sticky bit is set.
  \[ `-p`{.option} `FILE`{.filename} \]                        True if `FILE`{.filename} exists and is a named pipe (FIFO).
  \[ `-r`{.option} `FILE`{.filename} \]                        True if `FILE`{.filename} exists and is readable.
  \[ `-s`{.option} `FILE`{.filename} \]                        True if `FILE`{.filename} exists and has a size greater than zero.
  \[ `-t`{.option} `FD`{.filename} \]                          True if file descriptor `FD`{.filename} is open and refers to a terminal.
  \[ `-u`{.option} `FILE`{.filename} \]                        True if `FILE`{.filename} exists and its SUID (set user ID) bit is set.
  \[ `-w`{.option} `FILE`{.filename} \]                        True if `FILE`{.filename} exists and is writable.
  \[ `-x`{.option} `FILE`{.filename} \]                        True if `FILE`{.filename} exists and is executable.
  \[ `-O`{.option} `FILE`{.filename} \]                        True if `FILE`{.filename} exists and is owned by the effective user ID.
  \[ `-G`{.option} `FILE`{.filename} \]                        True if `FILE`{.filename} exists and is owned by the effective group ID.
  \[ `-L`{.option} `FILE`{.filename} \]                        True if `FILE`{.filename} exists and is a symbolic link.
  \[ `-N`{.option} `FILE`{.filename} \]                        True if `FILE`{.filename} exists and has been modified since it was last read.
  \[ `-S`{.option} `FILE`{.filename} \]                        True if `FILE`{.filename} exists and is a socket.
  \[ `FILE1`{.filename} `-nt`{.option} `FILE2`{.filename} \]   True if `FILE1`{.filename} has been changed more recently than `FILE2`{.filename}, or if `FILE1`{.filename} exists and `FILE2`{.filename} does not.
  \[ `FILE1`{.filename} `-ot`{.option} `FILE2`{.filename} \]   True if `FILE1`{.filename} is older than `FILE2`{.filename}, or is `FILE2`{.filename} exists and `FILE1`{.filename} does not.
  \[ `FILE1`{.filename} `-ef`{.option} `FILE2`{.filename} \]   True if `FILE1`{.filename} and `FILE2`{.filename} refer to the same device and inode numbers.
  \[ `-o`{.option} OPTIONNAME \]                               True if shell option [\"OPTIONNAME\"]{.QUOTE} is enabled.
  `[ -z`{.option} STRING \]                                    True of the length if [\"STRING\"]{.QUOTE} is zero.
  `[ -n`{.option} STRING \] or \[ STRING \]                    True if the length of [\"STRING\"]{.QUOTE} is non-zero.
  \[ STRING1 == STRING2 \]                                     True if the strings are equal. [\"=\"]{.QUOTE} may be used instead of [\"==\"]{.QUOTE} for strict POSIX compliance.
  \[ STRING1 != STRING2 \]                                     True if the strings are not equal.
  \[ STRING1 \< STRING2 \]                                     True if [\"STRING1\"]{.QUOTE} sorts before [\"STRING2\"]{.QUOTE} lexicographically in the current locale.
  \[ STRING1 \> STRING2 \]                                     True if [\"STRING1\"]{.QUOTE} sorts after [\"STRING2\"]{.QUOTE} lexicographically in the current locale.
  \[ ARG1 OP ARG2 \]                                           [\"OP\"]{.QUOTE} is one of `-eq`{.option}, `-ne`{.option}, `-lt`{.option}, `-le`{.option}, `-gt`{.option} or `-ge`{.option}. These arithmetic binary operators return true if [\"ARG1\"]{.QUOTE} is equal to, not equal to, less than, less than or equal to, greater than, or greater than or equal to [\"ARG2\"]{.QUOTE}, respectively. [\"ARG1\"]{.QUOTE} and [\"ARG2\"]{.QUOTE} are integers.
:::

Expressions may be combined using the following operators, listed in
decreasing order of precedence:

::: {.table}
[]{#tab_07_02}

**Table 7-2. Combining expressions**

  Operation              Effect
  ---------------------- -------------------------------------------------------------------------------------------------
  \[ ! EXPR \]           True if **EXPR** is false.
  \[ ( EXPR ) \]         Returns the value of **EXPR**. This may be used to override the normal precedence of operators.
  \[ EXPR1 -a EXPR2 \]   True if both **EXPR1** and **EXPR2** are true.
  \[ EXPR1 -o EXPR2 \]   True if either **EXPR1** or **EXPR2** is true.
:::

The **\[** (or **test**) built-in evaluates conditional expressions
using a set of rules based on the number of arguments. More information
about this subject can be found in the Bash documentation. Just like the
**if** is closed with **fi**, the opening square bracket should be
closed after the conditions have been listed.
:::

::: {.sect3}
### []{#sect_07_01_01_02}7.1.1.2. Commands following the then statement {#commands-following-the-then-statement .sect3}

The **CONSEQUENT-COMMANDS** list that follows the **then** statement can
be any valid UNIX command, any executable program, any executable shell
script or any shell statement, with the exception of the closing **fi**.
It is important to remember that the **then** and **fi** are considered
to be separated statements in the shell. Therefore, when issued on the
command line, they are separated by a semi-colon.

In a script, the different parts of the **if** statement are usually
well-separated. Below, a couple of simple examples.
:::

::: {.sect3}
### []{#sect_07_01_01_03}7.1.1.3. Checking files {#checking-files .sect3}

The first example checks for the existence of a file:

+-----------------------------------------------------------------------+
| ``` {.screen}                                                         |
| anny ~> cat msgcheck.sh                                              |
| #!/bin/bash                                                           |
|                                                                       |
| echo "This scripts checks the existence of the messages file."        |
| echo "Checking..."                                                    |
| if [ -f /var/log/messages ]                                           |
|   then                                                                |
|     echo "/var/log/messages exists."                                  |
| fi                                                                    |
| echo                                                                  |
| echo "...done."                                                       |
|                                                                       |
| anny ~> ./msgcheck.sh                                                 |
| This scripts checks the existence of the messages file.               |
| Checking...                                                           |
| /var/log/messages exists.                                             |
|                                                                       |
| ...done.                                                              |
| ```                                                                   |
+-----------------------------------------------------------------------+
:::

::: {.sect3}
### []{#sect_07_01_01_04}7.1.1.4. Checking shell options {#checking-shell-options .sect3}

To add in your Bash configuration files:

+-----------------------------------------------------------------------+
| ``` {.screen}                                                         |
| # These lines will print a message if the noclobber option is set:   |
|                                                                       |
| if [ -o noclobber ]                                                   |
|   then                                                                |
|     echo "Your files are protected against accidental overwriting usi |
| ng redirection."                                                      |
| fi                                                                    |
| ```                                                                   |
+-----------------------------------------------------------------------+

::: {.note}
+-----------------------------------+-----------------------------------+
| ![Note](http://tldp.org/LDP/Bash- | **The environment**               |
| Beginners-Guide/images/note.gif)  |                                   |
+-----------------------------------+-----------------------------------+
|                                   | The above example will work when  |
|                                   | entered on the command line:      |
|                                   |                                   |
|                                   | +------------------------------+  |
|                                   | | ``` {.screen}                |  |
|                                   | | anny ~> if [ -o noclobber ] |  |
|                                   | |  ; then echo ; echo "your fi |  |
|                                   | | les are protected            |  |
|                                   | | against overwriting." ; echo |  |
|                                   | |  ; fi                        |  |
|                                   | |                              |  |
|                                   | | your files are protected aga |  |
|                                   | | inst overwriting.            |  |
|                                   | |                              |  |
|                                   | | anny ~>                      |  |
|                                   | | ```                          |  |
|                                   | +------------------------------+  |
|                                   |                                   |
|                                   | However, if you use testing of    |
|                                   | conditions that depend on the     |
|                                   | environment, you might get        |
|                                   | different results when you enter  |
|                                   | the same command in a script,     |
|                                   | because the script will open a    |
|                                   | new shell, in which expected      |
|                                   | variables and options might not   |
|                                   | be set automatically.             |
+-----------------------------------+-----------------------------------+
:::
:::
:::

::: {.sect2}
[]{#sect_07_01_02}7.1.2. Simple applications of if {#simple-applications-of-if .sect2}
--------------------------------------------------

::: {.sect3}
### []{#sect_07_01_02_01}7.1.2.1. Testing exit status {#testing-exit-status .sect3}

The `?`{.varname} variable holds the exit status of the previously
executed command (the most recently completed foreground process).

The following example shows a simple test:

+-----------------------------------------------------------------------+
| ``` {.screen}                                                         |
| anny ~> if [ $? -eq 0 ]                                              |
| More input> then echo 'That was a good job!'                          |
| More input> fi                                                        |
| That was a good job!                                                  |
|                                                                       |
| anny ~>                                                               |
| ```                                                                   |
+-----------------------------------------------------------------------+

The following example demonstrates that **TEST-COMMANDS** might be any
UNIX command that returns an exit status, and that **if** again returns
an exit status of zero:

+-----------------------------------------------------------------------+
| ``` {.screen}                                                         |
| anny ~> if ! grep $USER /etc/passwd                                  |
| More input> then echo "your user account is not managed locally"; fi  |
| your user account is not managed locally                              |
|                                                                       |
| anny > echo $?                                                        |
| 0                                                                     |
|                                                                       |
| anny >                                                                |
| ```                                                                   |
+-----------------------------------------------------------------------+

The same result can be obtained as follows:

+-----------------------------------------------------------------------+
| ``` {.screen}                                                         |
| anny > grep $USER /etc/passwd                                        |
|                                                                       |
| anny > if [ $? -ne 0 ] ; then echo "not a local account" ; fi         |
| not a local account                                                   |
|                                                                       |
| anny >                                                                |
| ```                                                                   |
+-----------------------------------------------------------------------+
:::

::: {.sect3}
### []{#sect_07_01_02_02}7.1.2.2. Numeric comparisons {#numeric-comparisons .sect3}

The examples below use numerical comparisons:

+-----------------------------------------------------------------------+
| ``` {.screen}                                                         |
| anny > num=`wc -l work.txt`                                          |
|                                                                       |
| anny > echo $num                                                      |
| 201                                                                   |
|                                                                       |
| anny > if [ "$num" -gt "150" ]                                        |
| More input> then echo ; echo "you've worked hard enough for today."   |
| More input> echo ; fi                                                 |
|                                                                       |
| you've worked hard enough for today.                                  |
|                                                                       |
|                                                                       |
| anny >                                                                |
| ```                                                                   |
+-----------------------------------------------------------------------+

This script is executed by cron every Sunday. If the week number is
even, it reminds you to put out the garbage cans:

+-----------------------------------------------------------------------+
| ``` {.screen}                                                         |
| #!/bin/bash                                                          |
|                                                                       |
| # Calculate the week number using the date command:                   |
|                                                                       |
| WEEKOFFSET=$[ $(date +"%V") % 2 ]                                     |
|                                                                       |
| # Test if we have a remainder.  If not, this is an even week so send  |
| a message.                                                            |
| # Else, do nothing.                                                   |
|                                                                       |
| if [ $WEEKOFFSET -eq "0" ]; then                                      |
|   echo "Sunday evening, put out the garbage cans." | mail -s "Garbage |
|  cans out" your@your_domain.org                                       |
| fi                                                                    |
| ```                                                                   |
+-----------------------------------------------------------------------+
:::

::: {.sect3}
### []{#sect_07_01_02_03}7.1.2.3. String comparisons {#string-comparisons .sect3}

An example of comparing strings for testing the user ID:

+-----------------------------------------------------------------------+
| ``` {.screen}                                                         |
| if [ "$(whoami)" != 'root' ]; then                                   |
|         echo "You have no permission to run $0 as non-root user."     |
|         exit 1;                                                       |
| fi                                                                    |
| ```                                                                   |
+-----------------------------------------------------------------------+

With Bash, you can shorten this type of construct. The compact
equivalent of the above test is as follows:

+-----------------------------------------------------------------------+
| ``` {.screen}                                                         |
| [ "$(whoami)" != 'root' ] && ( echo you are using a non-privileged a |
| ccount; exit 1 )                                                      |
| ```                                                                   |
+-----------------------------------------------------------------------+

Similar to the [\"&&\"]{.QUOTE} expression which indicates what to do if
the test proves true, [\"\|\|\"]{.QUOTE} specifies what to do if the
test is false.

Regular expressions may also be used in comparisons:

+-----------------------------------------------------------------------+
| ``` {.screen}                                                         |
| anny > gender="female"                                               |
|                                                                       |
| anny > if [[ "$gender" == f* ]]                                       |
| More input> then echo "Pleasure to meet you, Madame."; fi             |
| Pleasure to meet you, Madame.                                         |
|                                                                       |
| anny >                                                                |
| ```                                                                   |
+-----------------------------------------------------------------------+

::: {.note}
+-----------------------------------+-----------------------------------+
| ![Note](http://tldp.org/LDP/Bash- | **Real Programmers**              |
| Beginners-Guide/images/note.gif)  |                                   |
+-----------------------------------+-----------------------------------+
|                                   | Most programmers will prefer to   |
|                                   | use the **test** built-in         |
|                                   | command, which is equivalent to   |
|                                   | using square brackets for         |
|                                   | comparison, like this:            |
|                                   |                                   |
|                                   | +------------------------------+  |
|                                   | | ``` {.screen}                |  |
|                                   | | test "$(whoami)" != 'root'  |  |
|                                   | | && (echo you are using a non |  |
|                                   | | -privileged account; exit 1) |  |
|                                   | | ```                          |  |
|                                   | +------------------------------+  |
+-----------------------------------+-----------------------------------+
:::

::: {.note}
+-----------------------------------+-----------------------------------+
| ![Note](http://tldp.org/LDP/Bash- | **No exit?**                      |
| Beginners-Guide/images/note.gif)  |                                   |
+-----------------------------------+-----------------------------------+
|                                   | If you invoke the **exit** in a   |
|                                   | subshell, it will not pass        |
|                                   | variables to the parent. Use {    |
|                                   | and } instead of ( and ) if you   |
|                                   | do not want Bash to fork a        |
|                                   | subshell.                         |
+-----------------------------------+-----------------------------------+
:::

See the info pages for Bash for more information on pattern matching
with the [\"(( EXPRESSION ))\"]{.QUOTE} and [\"\[\[ EXPRESSION
\]\]\"]{.QUOTE} constructs.
:::
:::
:::

::: {.NAVFOOTER}

------------------------------------------------------------------------

  ------------------------ -------------------- -------------------------
  [Prev](chap_07.md)      [Home](index.md)    [Next](sect_07_02.md)
  Conditional statements    [Up](chap_07.md)     More advanced if usage
  ------------------------ -------------------- -------------------------
:::
