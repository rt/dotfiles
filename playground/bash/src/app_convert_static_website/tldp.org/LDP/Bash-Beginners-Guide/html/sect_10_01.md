::: {.NAVHEADER}
Bash Guide for Beginners
:::

[Prev](chap_10.md)

Chapter 10. More on variables

[Next](sect_10_02.md)

------------------------------------------------------------------------

::: {.sect1}
[]{#sect_10_01}10.1. Types of variables {#types-of-variables .sect1}
=======================================

::: {.sect2}
[]{#sect_10_01_01}10.1.1. General assignment of values {#general-assignment-of-values .sect2}
------------------------------------------------------

As we already saw, Bash understands many different kinds of variables or
parameters. Thus far, we haven\'t bothered much with what kind of
variables we assigned, so our variables could hold any value that we
assigned to them. A simple command line example demonstrates this:

+-----------------------------------------------------------------------+
| ``` {.screen}                                                         |
| [bob in ~] VARIABLE=12                                               |
|                                                                       |
| [bob in ~] echo $VARIABLE                                             |
| 12                                                                    |
|                                                                       |
| [bob in ~] VARIABLE=string                                            |
|                                                                       |
| [bob in ~] echo $VARIABLE                                             |
| string                                                                |
| ```                                                                   |
+-----------------------------------------------------------------------+

There are cases when you want to avoid this kind of behavior, for
instance when handling telephone and other numbers. Apart from integers
and variables, you may also want to specify a variable that is a
constant. This is often done at the beginning of a script, when the
value of the constant is declared. After that, there are only references
to the constant variable name, so that when the constant needs to be
changed, it only has to be done once. A variable may also be a series of
variables of any type, a so-called *array* of variables
(`VAR0`{.varname}`VAR1`{.varname}, `VAR2`{.varname}, \...
`VARN`{.varname}).
:::

::: {.sect2}
[]{#sect_10_01_02}10.1.2. Using the declare built-in {#using-the-declare-built-in .sect2}
----------------------------------------------------

Using a **declare** statement, we can limit the value assignment to
variables.

The syntax for **declare** is the following:

**declare `OPTION(s)`{.option} `VARIABLE`{.varname}=value**

The following options are used to determine the type of data the
variable can hold and to assign it attributes:

::: {.table}
[]{#tab_10_01}

**Table 10-1. Options to the declare built-in**

  Option          Meaning
  --------------- -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  `-a`{.option}   Variable is an array.
  `-f`{.option}   Use function names only.
  `-i`{.option}   The variable is to be treated as an integer; arithmetic evaluation is performed when the variable is assigned a value (see [Section 3.4.6](sect_03_04.md#sect_03_04_05)).
  `-p`{.option}   Display the attributes and values of each variable. When `-p`{.option} is used, additional options are ignored.
  `-r`{.option}   Make variables read-only. These variables cannot then be assigned values by subsequent assignment statements, nor can they be unset.
  `-t`{.option}   Give each variable the *trace* attribute.
  `-x`{.option}   Mark each variable for export to subsequent commands via the environment.
:::

Using `+`{.option} instead of `-`{.option} turns off the attribute
instead. When used in a function, **declare** creates local variables.

The following example shows how assignment of a type to a variable
influences the value.

+-----------------------------------------------------------------------+
| ``` {.screen}                                                         |
| [bob in ~] declare -i VARIABLE=12                                    |
|                                                                       |
| [bob in ~] VARIABLE=string                                            |
|                                                                       |
| [bob in ~] echo $VARIABLE                                             |
| 0                                                                     |
|                                                                       |
| [bob in ~] declare -p VARIABLE                                        |
| declare -i VARIABLE="0"                                               |
| ```                                                                   |
+-----------------------------------------------------------------------+

Note that Bash has an option to declare a numeric value, but none for
declaring string values. This is because, by default, if no
specifications are given, a variable can hold any type of data:

+-----------------------------------------------------------------------+
| ``` {.screen}                                                         |
| [bob in ~] OTHERVAR=blah                                             |
|                                                                       |
| [bob in ~] declare -p OTHERVAR                                        |
| declare -- OTHERVAR="blah"                                            |
| ```                                                                   |
+-----------------------------------------------------------------------+

As soon as you restrict assignment of values to a variable, it can only
hold that type of data. Possible restrictions are either integer,
constant or array.

See the Bash info pages for information on return status.
:::

::: {.sect2}
[]{#sect_10_01_03}10.1.3. Constants {#constants .sect2}
-----------------------------------

In Bash, constants are created by making a variable read-only. The
**readonly** built-in marks each specified variable as unchangeable. The
syntax is:

**readonly `OPTION`{.option} `VARIABLE(s)`{.varname}**

The values of these variables can then no longer be changed by
subsequent assignment. If the `-f`{.option} option is given, each
variable refers to a shell function; see [Chapter 11](chap_11.md). If
`-a`{.option} is specified, each variable refers to an array of
variables. If no arguments are given, or if `-p`{.option} is supplied, a
list of all read-only variables is displayed. Using the `-p`{.option}
option, the output can be reused as input.

The return status is zero, unless an invalid option was specified, one
of the variables or functions does not exist, or `-f`{.option} was
supplied for a variable name instead of for a function name.

+-----------------------------------------------------------------------+
| ``` {.screen}                                                         |
| [bob in ~] readonly TUX=penguinpower                                 |
|                                                                       |
| [bob in ~] TUX=Mickeysoft                                             |
| bash: TUX: readonly variable                                          |
| ```                                                                   |
+-----------------------------------------------------------------------+
:::
:::

::: {.NAVFOOTER}

------------------------------------------------------------------------

  ---------------------- -------------------- -------------------------
  [Prev](chap_10.md)    [Home](index.md)    [Next](sect_10_02.md)
  More on variables       [Up](chap_10.md)            Array variables
  ---------------------- -------------------- -------------------------
:::
