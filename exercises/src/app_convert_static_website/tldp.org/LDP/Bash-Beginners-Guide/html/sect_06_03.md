::: {.NAVHEADER}
Bash Guide for Beginners
:::

[Prev](sect_06_02.md)

Chapter 6. The GNU awk programming language

[Next](sect_06_04.md)

------------------------------------------------------------------------

::: {.sect1}
[]{#sect_06_03}6.3. Gawk variables {#gawk-variables .sect1}
==================================

As **awk** is processing the input file, it uses several variables. Some
are editable, some are read-only.

::: {.sect2}
[]{#sect_06_03_01}6.3.1. The input field separator {#the-input-field-separator .sect2}
--------------------------------------------------

The *field separator*, which is either a single character or a regular
expression, controls the way **awk** splits up an input record into
fields. The input record is scanned for character sequences that match
the separator definition; the fields themselves are the text between the
matches.

The field separator is represented by the built-in variable
`FS`{.varname}. Note that this is something different from the
`IFS`{.varname} variable used by POSIX-compliant shells.

The value of the field separator variable can be changed in the **awk**
program with the assignment operator **=**. Often the right time to do
this is at the beginning of execution before any input has been
processed, so that the very first record is read with the proper
separator. To do this, use the special **BEGIN** pattern.

In the example below, we build a command that displays all the users on
your system with a description:

+-----------------------------------------------------------------------+
| ``` {.screen}                                                         |
| kelly is in ~> awk 'BEGIN { FS=":" } { print $1 "\t" $5 }' /etc/pass |
| wd                                                                    |
| --output omitted--                                                    |
| kelly   Kelly Smith                                                   |
| franky  Franky B.                                                     |
| eddy    Eddy White                                                    |
| willy   William Black                                                 |
| cathy   Catherine the Great                                           |
| sandy   Sandy Li Wong                                                 |
|                                                                       |
| kelly is in ~>                                                        |
| ```                                                                   |
+-----------------------------------------------------------------------+

In an **awk** script, it would look like this:

+-----------------------------------------------------------------------+
| ``` {.screen}                                                         |
| kelly is in ~> cat printnames.awk                                    |
| BEGIN { FS=":" }                                                      |
| { print $1 "\t" $5 }                                                  |
|                                                                       |
| kelly is in ~> awk -f printnames.awk /etc/passwd                      |
| --output omitted--                                                    |
| ```                                                                   |
+-----------------------------------------------------------------------+

Choose input field separators carefully to prevent problems. An example
to illustrate this: say you get input in the form of lines that look
like this:

[\"Sandy L. Wong, 64 Zoo St., Antwerp, 2000X\"]{.QUOTE}

You write a command line or a script, which prints out the name of the
person in that record:

**awk \'BEGIN { FS=\",\" } { print \$1, \$2, \$3 }\'
`inputfile`{.filename}**

But a person might have a PhD, and it might be written like this:

[\"Sandy L. Wong, PhD, 64 Zoo St., Antwerp, 2000X\"]{.QUOTE}

Your **awk** will give the wrong output for this line. If needed, use an
extra **awk** or **sed** to uniform data input formats.

The default input field separator is one or more whitespaces or tabs.
:::

::: {.sect2}
[]{#sect_06_03_02}6.3.2. The output separators {#the-output-separators .sect2}
----------------------------------------------

::: {.sect3}
### []{#sect_06_03_02_01}6.3.2.1. The output field separator {#the-output-field-separator .sect3}

Fields are normally separated by spaces in the output. This becomes
apparent when you use the correct syntax for the **print** command,
where arguments are separated by commas:

+-----------------------------------------------------------------------+
| ``` {.screen}                                                         |
| kelly@octarine ~/test> cat test                                      |
| record1         data1                                                 |
| record2         data2                                                 |
|                                                                       |
| kelly@octarine ~/test> awk '{ print $1 $2}' test                      |
| record1data1                                                          |
| record2data2                                                          |
|                                                                       |
| kelly@octarine ~/test> awk '{ print $1, $2}' test                     |
| record1 data1                                                         |
| record2 data2                                                         |
|                                                                       |
| kelly@octarine ~/test>                                                |
| ```                                                                   |
+-----------------------------------------------------------------------+

If you don\'t put in the commas, **print** will treat the items to
output as one argument, thus omitting the use of the default *output
separator*, `OFS`{.varname}.

Any character string may be used as the output field separator by
setting this built-in variable.
:::

::: {.sect3}
### []{#sect_06_03_02_02}6.3.2.2. The output record separator {#the-output-record-separator .sect3}

The output from an entire **print** statement is called an *output
record*. Each **print** command results in one output record, and then
outputs a string called the *output record separator*, `ORS`{.varname}.
The default value for this variable is [\"\\n\"]{.QUOTE}, a newline
character. Thus, each **print** statement generates a separate line.

To change the way output fields and records are separated, assign new
values to `OFS`{.varname} and `ORS`{.varname}:

+-----------------------------------------------------------------------+
| ``` {.screen}                                                         |
| kelly@octarine ~/test> awk 'BEGIN { OFS=";" ; ORS="\n-->\n" } \      |
| { print $1,$2}' test                                                  |
| record1;data1                                                         |
| -->                                                                   |
| record2;data2                                                         |
| -->                                                                   |
|                                                                       |
| kelly@octarine ~/test>                                                |
| ```                                                                   |
+-----------------------------------------------------------------------+

If the value of `ORS`{.varname} does not contain a newline, the
program\'s output is run together on a single line.
:::
:::

::: {.sect2}
[]{#sect_06_03_03}6.3.3. The number of records {#the-number-of-records .sect2}
----------------------------------------------

The built-in `NR`{.varname} holds the number of records that are
processed. It is incremented after reading a new input line. You can use
it at the end to count the total number of records, or in each output
record:

+-----------------------------------------------------------------------+
| ``` {.screen}                                                         |
| kelly@octarine ~/test> cat processed.awk                             |
| BEGIN { OFS="-" ; ORS="\n--> done\n" }                                |
| { print "Record number " NR ":\t" $1,$2 }                             |
| END { print "Number of records processed: " NR }                      |
|                                                                       |
| kelly@octarine ~/test> awk -f processed.awk test                      |
| Record number 1:        record1-data1                                 |
| --> done                                                              |
| Record number 2:        record2-data2                                 |
| --> done                                                              |
| Number of records processed: 2                                        |
| --> done                                                              |
|                                                                       |
| kelly@octarine ~/test>                                                |
| ```                                                                   |
+-----------------------------------------------------------------------+
:::

::: {.sect2}
[]{#sect_06_03_04}6.3.4. User defined variables {#user-defined-variables .sect2}
-----------------------------------------------

Apart from the built-in variables, you can define your own. When **awk**
encounters a reference to a variable which does not exist (which is not
predefined), the variable is created and initialized to a null string.
For all subsequent references, the value of the variable is whatever
value was assigned last. Variables can be a string or a numeric value.
Content of input fields can also be assigned to variables.

Values can be assigned directly using the **=** operator, or you can use
the current value of the variable in combination with other operators:

+-----------------------------------------------------------------------+
| ``` {.screen}                                                         |
| kelly@octarine ~> cat revenues                                       |
| 20021009        20021013        consultancy     BigComp         2500  |
| 20021015        20021020        training        EduComp         2000  |
| 20021112        20021123        appdev          SmartComp       10000 |
| 20021204        20021215        training        EduComp         5000  |
|                                                                       |
| kelly@octarine ~> cat total.awk                                       |
| { total=total + $5 }                                                  |
| { print "Send bill for " $5 " dollar to " $4 }                        |
| END { print "---------------------------------\nTotal revenue: " tota |
| l }                                                                   |
|                                                                       |
| kelly@octarine ~> awk -f total.awk test                               |
| Send bill for 2500 dollar to BigComp                                  |
| Send bill for 2000 dollar to EduComp                                  |
| Send bill for 10000 dollar to SmartComp                               |
| Send bill for 5000 dollar to EduComp                                  |
| ---------------------------------                                     |
| Total revenue: 19500                                                  |
|                                                                       |
| kelly@octarine ~>                                                     |
| ```                                                                   |
+-----------------------------------------------------------------------+

C-like shorthands like **`VAR`{.varname}+= value** are also accepted.
:::

::: {.sect2}
[]{#sect_06_03_05}6.3.5. More examples {#more-examples .sect2}
--------------------------------------

The example from [Section 5.3.2](sect_05_03.md#sect_05_03_02) becomes
much easier when we use an **awk** script:

+-----------------------------------------------------------------------+
| ``` {.screen}                                                         |
| kelly@octarine ~/html> cat make-html-from-text.awk                   |
| BEGIN { print "<html>\n<head><title>Awk-generated HTML</title></head> |
| \n<body bgcolor=\"#ffffff\">\n<pre>" }                                |
| { print $0 }                                                          |
| END { print "</pre>\n</body>\n</html>" }                              |
| ```                                                                   |
+-----------------------------------------------------------------------+

And the command to execute is also much more straightforward when using
**awk** instead of **sed**:

+-----------------------------------------------------------------------+
| ``` {.screen}                                                         |
| kelly@octarine ~/html> awk -f make-html-from-text.awk testfile > fil |
| e.md                                                                |
| ```                                                                   |
+-----------------------------------------------------------------------+

::: {.tip}
+-----------------------------------+-----------------------------------+
| ![Tip](http://tldp.org/LDP/Bash-B | **Awk examples on your system**   |
| eginners-Guide/images/tip.gif)    |                                   |
+-----------------------------------+-----------------------------------+
|                                   | We refer again to the directory   |
|                                   | containing the initscripts on     |
|                                   | your system. Enter a command      |
|                                   | similar to the following to see   |
|                                   | more practical examples of the    |
|                                   | widely spread usage of the        |
|                                   | **awk** command:                  |
|                                   |                                   |
|                                   | **grep `awk`{.parameter}          |
|                                   | `/etc/init.d/*`{.filename}**      |
+-----------------------------------+-----------------------------------+
:::
:::

::: {.sect2}
[]{#sect_06_03_06}6.3.6. The printf program {#the-printf-program .sect2}
-------------------------------------------

For more precise control over the output format than what is normally
provided by **print**, use **printf**. The **printf** command can be
used to specify the field width to use for each item, as well as various
formatting choices for numbers (such as what output base to use, whether
to print an exponent, whether to print a sign, and how many digits to
print after the decimal point). This is done by supplying a string,
called the *format string*, that controls how and where to print the
other arguments.

The syntax is the same as for the C-language **printf** statement; see
your C introduction guide. The **gawk** info pages contain full
explanations.
:::
:::

::: {.NAVFOOTER}

------------------------------------------------------------------------

  ------------------------- -------------------- -------------------------
  [Prev](sect_06_02.md)    [Home](index.md)    [Next](sect_06_04.md)
  The print program          [Up](chap_06.md)                    Summary
  ------------------------- -------------------- -------------------------
:::
