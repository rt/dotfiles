::: {.NAVHEADER}
Bash Guide for Beginners
:::

[Prev](chap_12.md)

Chapter 12. Catching signals

[Next](sect_12_02.md)

------------------------------------------------------------------------

::: {.sect1}
[]{#sect_12_01}12.1. Signals {#signals .sect1}
============================

::: {.sect2}
[]{#sect_12_01_01}12.1.1. Introduction {#introduction .sect2}
--------------------------------------

::: {.sect3}
### []{#sect_12_01_01_01}12.1.1.1. Finding the signal man page {#finding-the-signal-man-page .sect3}

Your system contains a man page listing all the available signals, but
depending on your operating system, it might be opened in a different
way. On most Linux systems, this will be **man `7`{.option} signal**.
When in doubt, locate the exact man page and section using commands like

**man `-k`{.option} signal \| grep `list`{.option}**

or

**apropos signal \| grep `list`{.option}**

Signal names can be found using **kill -l**.
:::

::: {.sect3}
### []{#sect_12_01_01_02}12.1.1.2. Signals to your Bash shell {#signals-to-your-bash-shell .sect3}

In the absence of any traps, an interactive Bash shell ignores *SIGTERM*
and *SIGQUIT*. *SIGINT* is caught and handled, and if job control is
active, *SIGTTIN*, *SIGTTOU* and *SIGTSTP* are also ignored. Commands
that are run as the result of a command substitution also ignore these
signals, when keyboard generated.

*SIGHUP* by default exits a shell. An interactive shell will send a
*SIGHUP* to all jobs, running or stopped; see the documentation on the
**disown** built-in if you want to disable this default behavior for a
particular process. Use the `huponexit`{.option} option for killing all
jobs upon receiving a *SIGHUP* signal, using the **shopt** built-in.
:::

::: {.sect3}
### []{#sect_12_01_01_03}12.1.1.3. Sending signals using the shell {#sending-signals-using-the-shell .sect3}

The following signals can be sent using the Bash shell:

::: {.table}
[]{#tab_12_01}

**Table 12-1. Control signals in Bash**

  Standard key combination   Meaning
  -------------------------- ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  **Ctrl**+**C**             The interrupt signal, sends SIGINT to the job running in the foreground.
  **Ctrl**+**Y**             The *delayed suspend* character. Causes a running process to be stopped when it attempts to read input from the terminal. Control is returned to the shell, the user can foreground, background or kill the process. Delayed suspend is only available on operating systems supporting this feature.
  **Ctrl**+**Z**             The *suspend* signal, sends a *SIGTSTP* to a running program, thus stopping it and returning control to the shell.
:::

::: {.note}
+-----------------------------------+-----------------------------------+
| ![Note](http://tldp.org/LDP/Bash- | **Terminal settings**             |
| Beginners-Guide/images/note.gif)  |                                   |
+-----------------------------------+-----------------------------------+
|                                   | Check your **stty** settings.     |
|                                   | Suspend and resume of output is   |
|                                   | usually disabled if you are using |
|                                   | [\"modern\"]{.QUOTE} terminal     |
|                                   | emulations. The standard          |
|                                   | **xterm** supports **Ctrl**+**S** |
|                                   | and **Ctrl**+**Q** by default.    |
+-----------------------------------+-----------------------------------+
:::
:::
:::

::: {.sect2}
[]{#sect_12_01_02}12.1.2. Usage of signals with kill {#usage-of-signals-with-kill .sect2}
----------------------------------------------------

Most modern shells, Bash included, have a built-in **kill** function. In
Bash, both signal names and numbers are accepted as options, and
arguments may be job or process IDs. An exit status can be reported
using the `-l`{.option} option: zero when at least one signal was
successfully sent, non-zero if an error occurred.

Using the **kill** command from `/usr/bin`{.filename}, your system might
enable extra options, such as the ability to kill processes from other
than your own user ID and specifying processes by name, like with
**pgrep** and **pkill**.

Both **kill** commands send the *TERM* signal if none is given.

This is a list of the most common signals:

::: {.table}
[]{#tab_12_02}

**Table 12-2. Common kill signals**

  Signal name   Signal value   Effect
  ------------- -------------- -------------------------
  SIGHUP        1              Hangup
  SIGINT        2              Interrupt from keyboard
  SIGKILL       9              Kill signal
  SIGTERM       15             Termination signal
  SIGSTOP       17,19,23       Stop the process
:::

::: {.note}
+-----------------------------------+-----------------------------------+
| ![Note](http://tldp.org/LDP/Bash- | **SIGKILL and SIGSTOP**           |
| Beginners-Guide/images/note.gif)  |                                   |
+-----------------------------------+-----------------------------------+
|                                   | *SIGKILL* and *SIGSTOP* can not   |
|                                   | be caught, blocked or ignored.    |
+-----------------------------------+-----------------------------------+
:::

When killing a process or series of processes, it is common sense to
start trying with the least dangerous signal, *SIGTERM*. That way,
programs that care about an orderly shutdown get the chance to follow
the procedures that they have been designed to execute when getting the
*SIGTERM* signal, such as cleaning up and closing open files. If you
send a *SIGKILL* to a process, you remove any chance for the process to
do a tidy cleanup and shutdown, which might have unfortunate
consequences.

But if a clean termination does not work, the *INT* or*KILL* signals
might be the only way. For instance, when a process does not die using
**Ctrl**+**C**, it is best to use the **kill `-9`{.option}** on that
process ID:

+-----------------------------------------------------------------------+
| ``` {.screen}                                                         |
| maud: ~> ps -ef | grep stuck_process                                 |
| maud    5607   2214  0 20:05 pts/5    00:00:02 stuck_process          |
|                                                                       |
| maud: ~> kill -9 5607                                                 |
|                                                                       |
| maud: ~> ps -ef | grep stuck_process                                  |
| maud    5614    2214 0 20:15 pts/5    00:00:00 grep stuck_process     |
| [1]+ Killed     stuck_process                                         |
| ```                                                                   |
+-----------------------------------------------------------------------+

When a process starts up several instances, **killall** might be easier.
It takes the same option as the **kill** command, but applies on all
instances of a given process. Test this command before using it in a
production environment, since it might not work as expected on some of
the commercial Unices.
:::
:::

::: {.NAVFOOTER}

------------------------------------------------------------------------

  ---------------------- -------------------- -------------------------
  [Prev](chap_12.md)    [Home](index.md)    [Next](sect_12_02.md)
  Catching signals        [Up](chap_12.md)                      Traps
  ---------------------- -------------------- -------------------------
:::
