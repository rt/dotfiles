::: {.NAVHEADER}
Bash Guide for Beginners
:::

[Prev](sect_03_03.md)

Chapter 3. The Bash environment

[Next](sect_03_05.md)

------------------------------------------------------------------------

::: {.sect1}
[]{#sect_03_04}3.4. Shell expansion {#shell-expansion .sect1}
===================================

::: {.sect2}
[]{#sect_03_04_0}3.4.1. General {#general .sect2}
-------------------------------

After the command has been split into *tokens* (see [Section
1.4.1.1](sect_01_04.md#sect_01_04_01_01)), these tokens or words are
expanded or resolved. There are eight kinds of expansion performed,
which we will discuss in the next sections, in the order that they are
expanded.

After all expansions, quote removal is performed.
:::

::: {.sect2}
[]{#sect_03_04_01}3.4.2. Brace expansion {#brace-expansion .sect2}
----------------------------------------

Brace expansion is a mechanism by which arbitrary strings may be
generated. Patterns to be brace-expanded take the form of an optional
*PREAMBLE*, followed by a series of comma-separated strings between a
pair of braces, followed by an optional *POSTSCRIPT*. The preamble is
prefixed to each string contained within the braces, and the postscript
is then appended to each resulting string, expanding left to right.

Brace expansions may be nested. The results of each expanded string are
not sorted; left to right order is preserved:

+-----------------------------------------------------------------------+
| ``` {.screen}                                                         |
| franky ~> echo sp{el,il,al}l                                         |
| spell spill spall                                                     |
| ```                                                                   |
+-----------------------------------------------------------------------+

Brace expansion is performed before any other expansions, and any
characters special to other expansions are preserved in the result. It
is strictly textual. Bash does not apply any syntactic interpretation to
the context of the expansion or the text between the braces. To avoid
conflicts with parameter expansion, the string [\"\${\"]{.QUOTE} is not
considered eligible for brace expansion.

A correctly-formed brace expansion must contain unquoted opening and
closing braces, and at least one unquoted comma. Any incorrectly formed
brace expansion is left unchanged.
:::

::: {.sect2}
[]{#sect_03_04_02}3.4.3. Tilde expansion {#tilde-expansion .sect2}
----------------------------------------

If a word begins with an unquoted tilde character ([\"\~\"]{.QUOTE}),
all of the characters up to the first unquoted slash (or all characters,
if there is no unquoted slash) are considered a *tilde-prefix*. If none
of the characters in the tilde-prefix are quoted, the characters in the
tilde-prefix following the tilde are treated as a possible login name.
If this login name is the null string, the tilde is replaced with the
value of the `HOME`{.varname} shell variable. If `HOME`{.varname} is
unset, the home directory of the user executing the shell is substituted
instead. Otherwise, the tilde-prefix is replaced with the home directory
associated with the specified login name.

If the tilde-prefix is [\"\~+\"]{.QUOTE}, the value of the shell
variable `PWD`{.varname} replaces the tilde-prefix. If the tilde-prefix
is [\"\~-\"]{.QUOTE}, the value of the shell variable
`OLDPWD`{.varname}, if it is set, is substituted.

If the characters following the tilde in the tilde-prefix consist of a
number N, optionally prefixed by a [\"+\"]{.QUOTE} or a [\"-\"]{.QUOTE},
the tilde-prefix is replaced with the corresponding element from the
directory stack, as it would be displayed by the **dirs** built-in
invoked with the characters following tilde in the tilde-prefix as an
argument. If the tilde-prefix, without the tilde, consists of a number
without a leading [\"+\"]{.QUOTE} or [\"-\"]{.QUOTE}, [\"+\"]{.QUOTE} is
assumed.

If the login name is invalid, or the tilde expansion fails, the word is
left unchanged.

Each variable assignment is checked for unquoted tilde-prefixes
immediately following a [\":\"]{.QUOTE} or [\"=\"]{.QUOTE}. In these
cases, tilde expansion is also performed. Consequently, one may use file
names with tildes in assignments to `PATH`{.varname},
`MAILPATH`{.varname}, and `CDPATH`{.varname}, and the shell assigns the
expanded value.

Example:

+-----------------------------------------------------------------------+
| ``` {.screen}                                                         |
| franky ~> export PATH="$PATH:~/testdir"                              |
| ```                                                                   |
+-----------------------------------------------------------------------+

`~/testdir`{.filename} will be expanded to
`$HOME`{.varname}`/testdir`{.filename}, so if `$HOME`{.varname} is
`/var/home/franky`{.filename}, the directory
`/var/home/franky/testdir`{.filename} will be added to the content of
the `PATH`{.varname} variable.
:::

::: {.sect2}
[]{#sect_03_04_03}3.4.4. Shell parameter and variable expansion {#shell-parameter-and-variable-expansion .sect2}
---------------------------------------------------------------

The [\"\$\"]{.QUOTE} character introduces parameter expansion, command
substitution, or arithmetic expansion. The parameter name or symbol to
be expanded may be enclosed in braces, which are optional but serve to
protect the variable to be expanded from characters immediately
following it which could be interpreted as part of the name.

When braces are used, the matching ending brace is the first
[\"}\"]{.QUOTE} not escaped by a backslash or within a quoted string,
and not within an embedded arithmetic expansion, command substitution,
or parameter expansion.

The basic form of parameter expansion is [\"\${PARAMETER}\"]{.QUOTE}.
The value of [\"PARAMETER\"]{.QUOTE} is substituted. The braces are
required when [\"PARAMETER\"]{.QUOTE} is a positional parameter with
more than one digit, or when [\"PARAMETER\"]{.QUOTE} is followed by a
character that is not to be interpreted as part of its name.

If the first character of [\"PARAMETER\"]{.QUOTE} is an exclamation
point, Bash uses the value of the variable formed from the rest of
[\"PARAMETER\"]{.QUOTE} as the name of the variable; this variable is
then expanded and that value is used in the rest of the substitution,
rather than the value of [\"PARAMETER\"]{.QUOTE} itself. This is known
as *indirect expansion*.

You are certainly familiar with straight parameter expansion, since it
happens all the time, even in the simplest of cases, such as the one
above or the following:

+-----------------------------------------------------------------------+
| ``` {.screen}                                                         |
| franky ~> echo $SHELL                                                |
| /bin/bash                                                             |
| ```                                                                   |
+-----------------------------------------------------------------------+

The following is an example of indirect expansion:

+-----------------------------------------------------------------------+
| ``` {.screen}                                                         |
| franky ~> echo ${!N*}                                                |
| NNTPPORT NNTPSERVER NPX_PLUGIN_PATH                                   |
| ```                                                                   |
+-----------------------------------------------------------------------+

Note that this is not the same as **echo `$N*`{.varname}**.

The following construct allows for creation of the named variable if it
does not yet exist:

**\${`VAR`{.varname}:=`value`{.parameter}}**

Example:

+-----------------------------------------------------------------------+
| ``` {.screen}                                                         |
| franky ~> echo $FRANKY                                               |
|                                                                       |
| franky ~> echo ${FRANKY:=Franky}                                      |
| Franky                                                                |
| ```                                                                   |
+-----------------------------------------------------------------------+

Special parameters, among others the positional parameters, may not be
assigned this way, however.

We will further discuss the use of the curly braces for treatment of
variables in [Chapter 10](chap_10.md). More information can also be
found in the Bash info pages.
:::

::: {.sect2}
[]{#sect_03_04_04}3.4.5. Command substitution {#command-substitution .sect2}
---------------------------------------------

Command substitution allows the output of a command to replace the
command itself. Command substitution occurs when a command is enclosed
like this:

**\$(command)**

or like this using backticks:

**\`command\`**

Bash performs the expansion by executing COMMAND and replacing the
command substitution with the standard output of the command, with any
trailing newlines deleted. Embedded newlines are not deleted, but they
may be removed during word splitting.

+-----------------------------------------------------------------------+
| ``` {.screen}                                                         |
| franky ~> echo `date`                                                |
| Thu Feb 6 10:06:20 CET 2003                                           |
| ```                                                                   |
+-----------------------------------------------------------------------+

When the old-style backquoted form of substitution is used, backslash
retains its literal meaning except when followed by [\"\$\"]{.QUOTE},
[\"\`\"]{.QUOTE}, or [\"\\\"]{.QUOTE}. The first backticks not preceded
by a backslash terminates the command substitution. When using the
[\"\$(COMMAND)\"]{.QUOTE} form, all characters between the parentheses
make up the command; none are treated specially.

Command substitutions may be nested. To nest when using the backquoted
form, escape the inner backticks with backslashes.

If the substitution appears within double quotes, word splitting and
file name expansion are not performed on the results.
:::

::: {.sect2}
[]{#sect_03_04_05}3.4.6. Arithmetic expansion {#arithmetic-expansion .sect2}
---------------------------------------------

Arithmetic expansion allows the evaluation of an arithmetic expression
and the substitution of the result. The format for arithmetic expansion
is:

**\$(( EXPRESSION ))**

The expression is treated as if it were within double quotes, but a
double quote inside the parentheses is not treated specially. All tokens
in the expression undergo parameter expansion, command substitution, and
quote removal. Arithmetic substitutions may be nested.

Evaluation of arithmetic expressions is done in fixed-width integers
with no check for overflow - although division by zero is trapped and
recognized as an error. The operators are roughly the same as in the C
programming language. In order of decreasing precedence, the list looks
like this:

::: {.table}
[]{#table_03_04}

**Table 3-4. Arithmetic operators**

  Operator                                                Meaning
  ------------------------------------------------------- --------------------------------------------
  VAR++ and VAR\--                                        variable post-increment and post-decrement
  ++VAR and \--VAR                                        variable pre-increment and pre-decrement
  \- and +                                                unary minus and plus
  ! and \~                                                logical and bitwise negation
  \*\*                                                    exponentiation
  \*, / and %                                             multiplication, division, remainder
  \+ and -                                                addition, subtraction
  \<\< and \>\>                                           left and right bitwise shifts
  \<=, \>=, \< and \>                                     comparison operators
  == and !=                                               equality and inequality
  &                                                       bitwise AND
  \^                                                      bitwise exclusive OR
  \|                                                      bitwise OR
  &&                                                      logical AND
  \|\|                                                    logical OR
  expr ? expr : expr                                      conditional evaluation
  =, \*=, /=, %=, +=, -=, \<\<=, \>\>=, &=, \^= and \|=   assignments
  ,                                                       separator between expressions
:::

Shell variables are allowed as operands; parameter expansion is
performed before the expression is evaluated. Within an expression,
shell variables may also be referenced by name without using the
parameter expansion syntax. The value of a variable is evaluated as an
arithmetic expression when it is referenced. A shell variable need not
have its integer attribute turned on to be used in an expression.

Constants with a leading 0 (zero) are interpreted as octal numbers. A
leading [\"0x\"]{.QUOTE} or [\"0X\"]{.QUOTE} denotes hexadecimal.
Otherwise, numbers take the form [\"\[BASE\'\#\'\]N\"]{.QUOTE}, where
[\"BASE\"]{.QUOTE} is a decimal number between 2 and 64 representing the
arithmetic base, and N is a number in that base. If
[\"BASE\'\#\'\"]{.QUOTE} is omitted, then base 10 is used. The digits
greater than 9 are represented by the lowercase letters, the uppercase
letters, [\"@\"]{.QUOTE}, and [\"\_\"]{.QUOTE}, in that order. If
[\"BASE\"]{.QUOTE} is less than or equal to 36, lowercase and uppercase
letters may be used interchangably to represent numbers between 10 and
35.

Operators are evaluated in order of precedence. Sub-expressions in
parentheses are evaluated first and may override the precedence rules
above.

Wherever possible, Bash users should try to use the syntax with square
brackets:

**\$\[ EXPRESSION \]**

However, this will only calculate the result of *EXPRESSION*, and do no
tests:

+-----------------------------------------------------------------------+
| ``` {.screen}                                                         |
| franky ~> echo $[365*24]                                             |
| 8760                                                                  |
| ```                                                                   |
+-----------------------------------------------------------------------+

See [Section 7.1.2.2](sect_07_01.md#sect_07_01_02_02), among others,
for practical examples in scripts.
:::

::: {.sect2}
[]{#sect_03_04_06}3.4.7. Process substitution {#process-substitution .sect2}
---------------------------------------------

Process substitution is supported on systems that support named pipes
(FIFOs) or the `/dev/fd`{.filename} method of naming open files. It
takes the form of

**\<(LIST)**

or

**\>(LIST)**

The process `LIST`{.varname} is run with its input or output connected
to a FIFO or some file in `/dev/fd`{.filename}. The name of this file is
passed as an argument to the current command as the result of the
expansion. If the [\"\>(LIST)\"]{.QUOTE} form is used, writing to the
file will provide input for `LIST`{.varname}. If the
[\"\<(LIST)\"]{.QUOTE} form is used, the file passed as an argument
should be read to obtain the output of `LIST`{.varname}. Note that no
space may appear between the \< or \> signs and the left parenthesis,
otherwise the construct would be interpreted as a redirection.

When available, process substitution is performed simultaneously with
parameter and variable expansion, command substitution, and arithmetic
expansion.

More information in [Section 8.2.3](sect_08_02.md#sect_08_02_03).
:::

::: {.sect2}
[]{#sect_03_04_07}3.4.8. Word splitting {#word-splitting .sect2}
---------------------------------------

The shell scans the results of parameter expansion, command
substitution, and arithmetic expansion that did not occur within double
quotes for word splitting.

The shell treats each character of `$IFS`{.varname} as a delimiter, and
splits the results of the other expansions into words on these
characters. If `IFS`{.varname} is unset, or its value is exactly
[\"\'\<space\>\<tab\>\<newline\>\'\"]{.QUOTE}, the default, then any
sequence of `IFS`{.varname} characters serves to delimit words. If
`IFS`{.varname} has a value other than the default, then sequences of
the whitespace characters [\"space\"]{.QUOTE} and [\"Tab\"]{.QUOTE} are
ignored at the beginning and end of the word, as long as the whitespace
character is in the value of `IFS`{.varname} (an `IFS`{.varname}
whitespace character). Any character in `IFS`{.varname} that is not
`IFS`{.varname} whitespace, along with any adjacent `IF`{.varname}
whitespace characters, delimits a field. A sequence of `IFS`{.varname}
whitespace characters is also treated as a delimiter. If the value of
`IFS`{.varname} is null, no word splitting occurs.

Explicit null arguments ([\"\"\"\"]{.QUOTE} or [\"\'\'\"]{.QUOTE}) are
retained. Unquoted implicit null arguments, resulting from the expansion
of parameters that have no values, are removed. If a parameter with no
value is expanded within double quotes, a null argument results and is
retained.

::: {.note}
+-----------------------------------+-----------------------------------+
| ![Note](http://tldp.org/LDP/Bash- | **Expansion and word splitting**  |
| Beginners-Guide/images/note.gif)  |                                   |
+-----------------------------------+-----------------------------------+
| Â                                  | If no expansion occurs, no        |
|                                   | splitting is performed.           |
+-----------------------------------+-----------------------------------+
:::
:::

::: {.sect2}
[]{#sect_03_04_08}3.4.9. File name expansion {#file-name-expansion .sect2}
--------------------------------------------

After word splitting, unless the `-f`{.option} option has been set (see
[Section 2.3.2](sect_02_03.md#sect_02_03_02)), Bash scans each word
for the characters [\"\*\"]{.QUOTE}, [\"?\"]{.QUOTE}, and
[\"\[\"]{.QUOTE}. If one of these characters appears, then the word is
regarded as a *PATTERN*, and replaced with an alphabetically sorted list
of file names matching the pattern. If no matching file names are found,
and the shell option `nullglob`{.option} is disabled, the word is left
unchanged. If the `nullglob`{.option} option is set, and no matches are
found, the word is removed. If the shell option `nocaseglob`{.option} is
enabled, the match is performed without regard to the case of alphabetic
characters.

When a pattern is used for file name generation, the character
[\".\"]{.QUOTE} at the start of a file name or immediately following a
slash must be matched explicitly, unless the shell option
`dotglob`{.option} is set. When matching a file name, the slash
character must always be matched explicitly. In other cases, the
[\".\"]{.QUOTE} character is not treated specially.

The `GLOBIGNORE`{.varname} shell variable may be used to restrict the
set of file names matching a pattern. If `GLOBIGNORE`{.varname} is set,
each matching file name that also matches one of the patterns in
`GLOBIGNORE`{.varname} is removed from the list of matches. The file
names `.`{.filename} and `..`{.filename} are always ignored, even when
`GLOBIGNORE`{.varname} is set. However, setting `GLOBIGNORE`{.varname}
has the effect of enabling the `dotglob`{.option} shell option, so all
other file names beginning with a [\".\"]{.QUOTE} will match. To get the
old behavior of ignoring file names beginning with a [\".\"]{.QUOTE},
make [\".\*\"]{.QUOTE} one of the patterns in `GLOBIGNORE`{.varname}.
The `dotglob`{.option} option is disabled when `GLOBIGNORE`{.varname} is
unset.
:::
:::

::: {.NAVFOOTER}

------------------------------------------------------------------------

  ------------------------- -------------------- -------------------------
  [Prev](sect_03_03.md)    [Home](index.md)    [Next](sect_03_05.md)
  Quoting characters         [Up](chap_03.md)                    Aliases
  ------------------------- -------------------- -------------------------
:::
